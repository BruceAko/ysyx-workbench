# pa1

## 计算机是否可以没有寄存器？

有一种编程范式叫做“stack oriented programming”，它依赖于一种称为“stack machine”的机器。当然，如果在内存中分配一组固定数量的地址来替代寄存器的功能，那么就可以避免使用寄存器。

## 为什么在init_monitor()函数中都是函数调用？

将具体的操作按照阶段划分成多个部分，然后将其封装成函数，这是一种抽象的方法。这样做有助于后期修改（因为不同函数之间相对独立或几乎无关），方便后期调试（可以轻松地在某个阶段的功能上设置断点），并且可以隐藏不必要的细节，提高代码的可读性。

## argc和**argv的来源是什么？

这些参数很可能是由运行程序的人提供的。在命令行中输入参数时，这些参数由命令行提供；如果被其他程序调用，则是调用者提供的。在Linux上，程序是通过execve(2)系统调用启动的，该系统调用将参数传递给main函数。实际上，调用者通过操作系统来运行其他程序，参数传递过程是由操作系统完成的。根据《CSAPP》的内容，数值参数是通过寄存器传递的，而具体的字符串参数则存储在堆栈上。因此，操作系统的任务就是传递argc和**argv这两个值，然后将参数压入堆栈中。

## 程序究竟要执行多久？

观察到传入形参的类型是uint64_t，因此传入-1表示传入一个最大值。进一步观察后发现循环是for (;n>0;n--)，因此传入-1时将执行最大次数。

## 传入-1是否会导致未定义行为（UB）？

查阅文档后发现，如果新类型是无符号的，那么该值将通过重复添加或减去新类型中可以表示的最大值来进行转换，直到该值在新类型的范围内。这里的“添加”和“减去”都是数学操作，与类型无关，是无界的。因此，传入-1的行为取决于无符号形参的类型，这不会导致未定义行为。

## 为什么在printf之后要加上\n？

首先，这是为了提高可读性，将所有输出显示在同一行很难阅读。其次，查阅资料后发现，如果不在printf格式字符串的末尾加上\n，则一些输出会留在标准输出缓冲区中，需要调用fflush才能将所有输出显示出来。标准输出使用输出缓冲区来临时保存整行输出，printf("\n")实际上刷新了缓冲区。如果不刷新缓冲区，标准输出的行为就无法保证是即时的。此外，如果标准输出被检测到是与交互式设备有关的，那么它将使用行缓冲，否则将使用完全缓冲。

## 除以0的确切行为是什么？

在启用较高级的编译优化时，常量表达式的计算将在编译期间进行，因此最终编译器将得到一个expr/0的表达式，会发出警告。只需修改编译命令，添加-O2 -Wall -Werror，就可以让编译器在编译期计算表达式的值，并将警告转换为错误。然后，可以根据GCC的返回值是否为0来判断是否存在除以0的行为。

## static关键字的作用是什么？

static变量存储在静态区，具有与全局变量相同的生命周期，但作用域与局部变量相同。static变量只会被初始化一次，static修饰的变量和函数对其他编译单元不可见，提供了类似于类中私有成员函数的功能。

## 为什么可以在任何地方设置断点？

因为每次解析指令时都是从程序计数器（PC）开始的，并且PC只会经历所有指令的开头和结尾，所以在指令的中间设置断点会跳过这个断点。
