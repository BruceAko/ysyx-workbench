# pa1

## 必答题

### 程序是个状态机

画出计算1+2+...+100的程序的状态机.

**(0, x, x) -> (1, 0, x) -> (2, 0, 0) -> (3, 0, 1) -> (4, 1, 1) -> (2, 1, 1) -> (3, 1, 2) -> (4, 3, 2) -> (2, 3, 2) -> (3, 3, 3) -> (4, 6, 3) -> (2, 6, 3) -> (3, 6, 4) -> (4, 10, 4) -> (2, 10, 4) -> (3, 10, 5) -> (4, 15, 5) -> …… -> (4, 4950, 99) -> (2, 4950, 99) -> (3, 4950, 100) -> (4, 5050, 100) -> (5, 5050, 100) -> (5, 5050, 100) -> ……**

### 理解基础设施

我们通过一些简单的计算来体会简易调试器的作用. 首先作以下假设:

- 假设你需要编译500次NEMU才能完成PA.
- 假设这500次编译当中, 有90%的次数是用于调试.
- 假设你没有实现简易调试器, 只能通过GDB对运行在NEMU上的客户程序进行调试. 在每一次调试中, 由于GDB不能直接观测客户程序, 你需要花费30秒的时间来从GDB中获取并分析一个信息.
- 假设你需要获取并分析20个信息才能排除一个bug.

那么这个学期下来, 你将会在调试上花费多少时间?

**500 \* 90% \* 30 \* 20 = 270000s = 4500min = 75h**

由于简易调试器可以直接观测客户程序, 假设通过简易调试器只需要花费10秒的时间从中获取并分析相同的信息. 那么这个学期下来, 简易调试器可以帮助你节省多少调试的时间?

**500 \* 90% \* 10 \* 20 = 90000s = 1500min = 25h**

**可以节约75-25=50个小时的调试时间。**

### RTFM

理解了科学查阅手册的方法之后, 请你尝试在你选择的ISA手册中查阅以下问题所在的位置, 把需要阅读的范围写到你的实验报告里面:

- riscv32有哪几种指令格式?

**riscv32有R、I、S、B、U、J共6种指令格式。（卷I P16）**

- LUI指令的行为是什么?

**LUI指令是将20位立即数加载到目标寄存器rd的高20位，并在低12位填入0。（卷I P19）**

- mstatus寄存器的结构是怎么样的?

**mstatus寄存器在RV32和RV64中的结构分别如下图所示：（卷Ⅱ P20）**

![pic](https://pic2.zhimg.com/v2-6e7ef91986b408cb38cb82a5ac4acb35_r.jpg)

### shell命令

完成PA1的内容之后, nemu/src目录下的所有.c和.h和文件总共有多少行代码? 你是使用什么命令得到这个结果的? 和框架代码相比, 你在PA1中编写了多少行代码? (Hint: 目前pa0分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到"过去"?) 你可以把这条命令写入Makefile中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数, 例如敲入make count就会自动运行统计代码行数的命令. 再来个难一点的, 除去空行之外, nemu/目录下的所有.c和.h文件总共有多少行代码?

**使用命令find . -name "*[.h|.c]" |xargs cat|wc -l得出来的行数是3974。**

**框架代码有3546行，我编写了428行代码**

**使用命令find . -name "*[.h|.c]" |xargs cat|grep -v ^$|wc -l过滤空行后，得出的行数是3470。**

### RTFM

打开nemu/scripters/build.mk文件, 你会在CFLAGS变量中看到gcc的一些编译选项. 请解释gcc中的-Wall和-Werror有什么作用? 为什么要使用-Wall和-Werror?

**-Wall的作用是打开gcc所有警告，-Werror的作用是要求gcc将所有警告当成错误处理。使用-Wall和-Werror是为了在编译期就尽早发现程序可能在运行时会出现的错误，提高调试的效率。**

## 其他问答

### 计算机是否可以没有寄存器？

有一种编程范式叫做“stack oriented programming”，它依赖于一种称为“stack machine”的机器。当然，如果在内存中分配一组固定数量的地址来替代寄存器的功能，那么就可以避免使用寄存器。

### 为什么在init_monitor()函数中都是函数调用？

将具体的操作按照阶段划分成多个部分，然后将其封装成函数，这是一种抽象的方法。这样做有助于后期修改（因为不同函数之间相对独立或几乎无关），方便后期调试（可以轻松地在某个阶段的功能上设置断点），并且可以隐藏不必要的细节，提高代码的可读性。

### argc和**argv的来源是什么？

这些参数很可能是由运行程序的人提供的。在命令行中输入参数时，这些参数由命令行提供；如果被其他程序调用，则是调用者提供的。在Linux上，程序是通过execve(2)系统调用启动的，该系统调用将参数传递给main函数。实际上，调用者通过操作系统来运行其他程序，参数传递过程是由操作系统完成的。根据《CSAPP》的内容，数值参数是通过寄存器传递的，而具体的字符串参数则存储在堆栈上。因此，操作系统的任务就是传递argc和**argv这两个值，然后将参数压入堆栈中。

### 程序究竟要执行多久？

观察到传入形参的类型是uint64_t，因此传入-1表示传入一个最大值。进一步观察后发现循环是for (;n>0;n--)，因此传入-1时将执行最大次数。

### 传入-1是否会导致未定义行为（UB）？

查阅文档后发现，如果新类型是无符号的，那么该值将通过重复添加或减去新类型中可以表示的最大值来进行转换，直到该值在新类型的范围内。这里的“添加”和“减去”都是数学操作，与类型无关，是无界的。因此，传入-1的行为取决于无符号形参的类型，这不会导致未定义行为。

### 为什么在printf之后要加上\n？

首先，这是为了提高可读性，将所有输出显示在同一行很难阅读。其次，查阅资料后发现，如果不在printf格式字符串的末尾加上\n，则一些输出会留在标准输出缓冲区中，需要调用fflush才能将所有输出显示出来。标准输出使用输出缓冲区来临时保存整行输出，printf("\n")实际上刷新了缓冲区。如果不刷新缓冲区，标准输出的行为就无法保证是即时的。此外，如果标准输出被检测到是与交互式设备有关的，那么它将使用行缓冲，否则将使用完全缓冲。

### 除以0的确切行为是什么？

在启用较高级的编译优化时，常量表达式的计算将在编译期间进行，因此最终编译器将得到一个expr/0的表达式，会发出警告。只需修改编译命令，添加-O2 -Wall -Werror，就可以让编译器在编译期计算表达式的值，并将警告转换为错误。然后，可以根据GCC的返回值是否为0来判断是否存在除以0的行为。

### static关键字的作用是什么？

static变量存储在静态区，具有与全局变量相同的生命周期，但作用域与局部变量相同。static变量只会被初始化一次，static修饰的变量和函数对其他编译单元不可见，提供了类似于类中私有成员函数的功能。

### 为什么可以在任何地方设置断点？

因为每次解析指令时都是从程序计数器（PC）开始的，并且PC只会经历所有指令的开头和结尾，所以在指令的中间设置断点会跳过这个断点。
